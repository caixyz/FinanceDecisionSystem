#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
修复所有垃圾数据 - 将市场板块数据替换为真实行业分类
基于股票名称智能识别行业分类
"""
import sqlite3
import pandas as pd
import re
from typing import Dict, List, Tuple

class IndustryFixer:
    """行业数据修复器"""
    
    def __init__(self):
        self.conn = sqlite3.connect('data/finance_data.db')
        self.cursor = self.conn.cursor()
        
        # 行业关键词映射
        self.industry_keywords = {
            '银行': ['银行', '商行', '储蓄'],
            '证券': ['证券', '券商', '证券股份'],
            '保险': ['保险', '人寿', '财产险', '健康险'],
            '酿酒行业': ['茅台', '五粮液', '泸州老窖', '汾酒', '古井贡', '洋河', '啤酒', '白酒', '黄酒', '葡萄酒', '酒鬼酒'],
            '食品饮料': ['食品', '饮料', '乳品', '乳业', '调味品', '肉制品', '食用油'],
            '医药制造': ['医药', '制药', '药业', '生物', '医疗', '健康', '疫苗', '中药', '西药'],
            '家电行业': ['家电', '电器', '空调', '冰箱', '洗衣机', '美的', '格力', '海尔', 'TCL'],
            '房地产': ['地产', '房地产', '置业', '物业', '建设', '城建', '房产'],
            '汽车整车': ['汽车', '轿车', '客车', '货车', '新能源', '比亚迪', '长城', '吉利', '长安'],
            '电力行业': ['电力', '电网', '发电', '供电', '能源', '水电', '火电', '核电'],
            '钢铁': ['钢铁', '钢', '铁', '冶金', '不锈钢', '宝钢', '鞍钢', '首钢'],
            '有色金属': ['有色', '铜', '铝', '铅', '锌', '黄金', '稀土', '锂', '钴', '镍'],
            '煤炭': ['煤炭', '煤矿', '能源', '煤业', '焦煤', '动力煤'],
            '石油': ['石油', '石化', '天然气', '油气', '中石油', '中石化', '中海油'],
            '化工': ['化工', '化学', '化肥', '农药', '塑料', '橡胶', '化纤', '染料'],
            '机械': ['机械', '机床', '设备', '重工', '工程机械', '装备制造'],
            '电子': ['电子', '半导体', '芯片', '集成电路', '电子元件', '消费电子'],
            '通信': ['通信', '电信', '移动', '联通', '电信', '5G', '通信设备'],
            '计算机': ['计算机', '软件', '信息', '科技', '互联网', '云计算', '大数据', '人工智能'],
            '传媒': ['传媒', '文化', '影视', '出版', '广告', '游戏', '动漫', '新媒体'],
            '交通运输': ['交通', '运输', '物流', '航运', '港口', '机场', '铁路', '公路', '快递'],
            '零售': ['零售', '超市', '百货', '商业', '连锁', '电商', '网购'],
            '建材': ['建材', '水泥', '玻璃', '陶瓷', '石材', '装饰材料'],
            '农业': ['农业', '农', '牧', '渔', '林', '种业', '化肥', '农药', '饲料'],
            '环保': ['环保', '环境', '水处理', '固废', '大气治理', '清洁能源'],
            '军工': ['军工', '国防', '航天', '航空', '船舶', '兵器', '军工电子'],
            '教育': ['教育', '学校', '培训', '在线教育', '职业教育'],
            '旅游': ['旅游', '酒店', '景区', '旅行社', '餐饮', '度假村'],
            '珠宝首饰': ['珠宝', '首饰', '黄金', '钻石', '饰品', '菜百'],
            '纺织服装': ['服装', '纺织', '服饰', '鞋帽', '家纺', '面料'],
            '造纸': ['造纸', '纸业', '纸浆', '包装', '印刷'],
            '建筑': ['建筑', '工程', '施工', '基建', '建筑安装'],
        }
    
    def get_industry_by_name(self, stock_name: str, symbol: str) -> str:
        """根据股票名称和代码智能识别行业"""
        stock_name = str(stock_name).upper()
        symbol = str(symbol)
        
        # 特殊股票映射
        special_mapping = {
            '601398': '银行',
            '600036': '银行',
            '000001': '银行',
            '601288': '银行',
            '601939': '银行',
            '601988': '银行',
            '600519': '酿酒行业',
            '000858': '酿酒行业',
            '000568': '酿酒行业',
            '000799': '酿酒行业',
            '600030': '证券',
            '601688': '证券',
            '000776': '证券',
            '601211': '证券',
            '601318': '保险',
            '601628': '保险',
            '601336': '保险',
            '605599': '珠宝首饰',
            '000002': '房地产',
            '000333': '家电行业',
            '000651': '家电行业',
            '000725': '电子',
            '000063': '通信',
            '000100': '家电行业',
            '000423': '医药制造',
            '000538': '医药制造',
            '000596': '酿酒行业',
            '000617': '证券',
            '000623': '医药制造',
            '000625': '汽车整车',
            '000629': '有色金属',
            '000630': '有色金属',
            '000651': '家电行业',
            '000656': '房地产',
            '000671': '房地产',
            '000686': '证券',
            '000690': '电力行业',
            '000708': '钢铁',
            '000709': '钢铁',
            '000712': '证券',
            '000713': '农业',
            '000716': '食品饮料',
            '000718': '房地产',
            '000720': '电力行业',
            '000725': '电子',
            '000728': '证券',
            '000729': '酿酒行业',
            '000732': '房地产',
            '000735': '农业',
            '000738': '军工',
            '000750': '证券',
            '000751': '有色金属',
            '000768': '军工',
            '000776': '证券',
            '000778': '钢铁',
            '000783': '证券',
            '000786': '建材',
            '000792': '化工',
            '000793': '传媒',
            '000800': '汽车整车',
            '000807': '有色金属',
            '000816': '机械',
            '000825': '钢铁',
            '000826': '环保',
            '000830': '化工',
            '000831': '有色金属',
            '000839': '传媒',
            '000858': '酿酒行业',
            '000860': '食品饮料',
            '000869': '酿酒行业',
            '000876': '农业',
            '000877': '建材',
            '000878': '有色金属',
            '000883': '电力行业',
            '000887': '汽车整车',
            '000895': '食品饮料',
            '000897': '房地产',
            '000898': '钢铁',
            '000900': '交通运输',
            '000901': '机械',
            '000917': '传媒',
            '000918': '房地产',
            '000919': '医药制造',
            '000921': '家电行业',
            '000922': '电力行业',
            '000923': '机械',
            '000925': '交通运输',
            '000926': '房地产',
            '000927': '汽车整车',
            '000928': '有色金属',
            '000930': '农业',
            '000933': '煤炭',
            '000937': '煤炭',
            '000938': '计算机',
            '000939': '电力行业',
            '000948': '医药制造',
            '000949': '化工',
            '000950': '医药制造',
            '000951': '汽车整车',
            '000952': '医药制造',
            '000953': '化工',
            '000955': '汽车整车',
            '000957': '汽车整车',
            '000958': '电力行业',
            '000959': '钢铁',
            '000960': '有色金属',
            '000961': '房地产',
            '000962': '有色金属',
            '000963': '医药制造',
            '000965': '房地产',
            '000966': '电力行业',
            '000967': '环保',
            '000968': '煤炭',
            '000969': '有色金属',
            '000970': '有色金属',
            '000975': '有色金属',
            '000977': '计算机',
            '000978': '旅游',
            '000979': '房地产',
            '000980': '汽车整车',
            '000981': '房地产',
            '000982': '纺织服装',
            '000983': '煤炭',
            '000985': '煤炭',
            '000987': '证券',
            '000988': '计算机',
            '000989': '医药制造',
            '000990': '化工',
            '000993': '电力行业',
            '000995': '传媒',
            '000996': '证券',
            '000997': '计算机',
            '000998': '农业',
            '000999': '医药制造',
        }
        
        # 特殊股票代码映射
        if symbol in special_mapping:
            return special_mapping[symbol]
        
        # 关键词匹配
        for industry, keywords in self.industry_keywords.items():
            for keyword in keywords:
                if keyword.upper() in stock_name:
                    return industry
        
        # 默认返回其他
        return '其他'
    
    def get_market_board_stocks(self) -> List[Tuple]:
        """获取所有市场板块数据的股票"""
        self.cursor.execute('''
            SELECT symbol, name, industry
            FROM stock_info
            WHERE industry IN ('上证主板', '深证主板', '创业板', '科创板', '北交所')
            ORDER BY symbol
        ''')
        return self.cursor.fetchall()
    
    def fix_single_stock(self, symbol: str, name: str, current_industry: str) -> str:
        """修复单只股票的行业分类"""
        new_industry = self.get_industry_by_name(name, symbol)
        
        if new_industry != current_industry:
            self.cursor.execute('''
                UPDATE stock_info 
                SET industry = ?, updated_at = datetime('now')
                WHERE symbol = ?
            ''', (new_industry, symbol))
            
        return new_industry
    
    def fix_all_garbage_data(self):
        """修复所有垃圾数据"""
        print("🚀 开始修复所有垃圾数据...")
        print("=" * 60)
        
        # 1. 获取需要修复的股票
        market_board_stocks = self.get_market_board_stocks()
        total_count = len(market_board_stocks)
        
        print(f"📊 发现 {total_count} 只股票需要修复")
        
        if total_count == 0:
            print("✅ 没有需要修复的垃圾数据")
            return
        
        # 2. 分批修复
        fixed_count = 0
        batch_size = 100
        
        for i, (symbol, name, current_industry) in enumerate(market_board_stocks):
            try:
                new_industry = self.fix_single_stock(symbol, name, current_industry)
                fixed_count += 1
                
                if i % batch_size == 0:
                    self.conn.commit()
                    print(f"🔄 已修复 {fixed_count}/{total_count} 只股票")
                
            except Exception as e:
                print(f"❌ 修复 {symbol} 失败: {e}")
        
        # 3. 提交最终更改
        self.conn.commit()
        
        # 4. 显示修复结果统计
        self.show_fix_statistics()
        
        print(f"🎉 数据修复完成！共修复 {fixed_count} 只股票")
    
    def show_fix_statistics(self):
        """显示修复后的统计信息"""
        print("\n📈 修复后的行业分布:")
        print("-" * 40)
        
        self.cursor.execute('''
            SELECT industry, COUNT(*) as count
            FROM stock_info
            WHERE industry NOT IN ('上证主板', '深证主板', '创业板', '科创板', '北交所')
            AND industry IS NOT NULL AND industry != ''
            GROUP BY industry
            ORDER BY count DESC
            LIMIT 20
        ''')
        
        results = self.cursor.fetchall()
        for industry, count in results:
            print(f"  {industry}: {count}只股票")
        
        # 统计剩余垃圾数据
        self.cursor.execute('''
            SELECT industry, COUNT(*) as count
            FROM stock_info
            WHERE industry IN ('上证主板', '深证主板', '创业板', '科创板', '北交所')
            GROUP BY industry
            ORDER BY count DESC
        ''')
        
        remaining = self.cursor.fetchall()
        if remaining:
            print("\n⚠️ 剩余未修复的垃圾数据:")
            for industry, count in remaining:
                print(f"  {industry}: {count}只股票")
        else:
            print("\n✅ 所有垃圾数据已修复完成！")
    
    def close(self):
        """关闭数据库连接"""
        self.conn.close()

def main():
    """主函数"""
    fixer = IndustryFixer()
    try:
        fixer.fix_all_garbage_data()
    finally:
        fixer.close()

if __name__ == "__main__":
    main()